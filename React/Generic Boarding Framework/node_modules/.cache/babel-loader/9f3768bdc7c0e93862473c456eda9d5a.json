{"ast":null,"code":"import _defineProperty from \"/Users/elgstrom/Desktop/Netgain/netgain-1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { ProcessInstance, ActivityInstance } from \"./common_define\";\nconst DB_NAME = \"test_db\";\nconst DB_VERSION = 2;\nexport let DB_OBJ_STORES;\n\n(function (DB_OBJ_STORES) {\n  DB_OBJ_STORES[\"process_instances\"] = \"process_instances\";\n  DB_OBJ_STORES[\"process_templates\"] = \"process_templates\";\n  DB_OBJ_STORES[\"activity_templates\"] = \"activity_templates\";\n})(DB_OBJ_STORES || (DB_OBJ_STORES = {}));\n\nexport function init_database() {\n  let indexedDB = window.indexedDB;\n  let open = indexedDB.open(DB_NAME, DB_VERSION);\n\n  open.onupgradeneeded = function () {\n    let db = open.result;\n\n    for (let store in DB_OBJ_STORES) {\n      if (!db.objectStoreNames.contains(store)) {\n        db.createObjectStore(store, {\n          autoIncrement: true\n        });\n      }\n    }\n  };\n}\n\nfunction connect_2_object_store(obj_s_name, callback) {\n  let indexedDB = window.indexedDB;\n  let open = indexedDB.open(DB_NAME, DB_VERSION);\n\n  open.onupgradeneeded = function () {\n    init_database();\n  };\n\n  open.onsuccess = function () {\n    let db = open.result;\n\n    if (!db.objectStoreNames.contains(obj_s_name)) {\n      db.createObjectStore(obj_s_name);\n    }\n\n    let tx = db.transaction(obj_s_name, \"readwrite\");\n    let store = tx.objectStore(obj_s_name);\n    callback(store);\n  };\n}\n\nexport function save_process_template(p) {\n  connect_2_object_store(DB_OBJ_STORES.process_templates, store => {\n    store.put(p, p.title);\n  });\n}\nexport async function does_process_exist(process_title) {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(DB_OBJ_STORES.process_templates, store => {\n      let request = store.get(process_title);\n\n      request.onsuccess = function () {\n        if (request.result) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n      };\n    });\n  });\n}\nexport function delete_process_template(p) {\n  connect_2_object_store(DB_OBJ_STORES.process_templates, store => {\n    store.delete(p.title);\n  });\n}\nexport function save_activity_template(a) {\n  connect_2_object_store(DB_OBJ_STORES.activity_templates, store => {\n    store.put(a, a.title);\n  });\n}\nexport async function does_activity_exist(activity_title) {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(DB_OBJ_STORES.activity_templates, store => {\n      let request = store.get(activity_title);\n\n      request.onsuccess = function () {\n        if (request.result) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n      };\n    });\n  });\n}\nexport function delete_activity_template(a) {\n  connect_2_object_store(DB_OBJ_STORES.activity_templates, store => {\n    store.delete(a.title);\n  });\n}\nexport function delete_process_instance(p) {\n  connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n    store.delete(new Array(p.title, p.user_name));\n  });\n}\nexport function create_process_instance(process_template, user_name) {\n  connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n    //TODO is there a better way of doing this? than using as (can cause problems with undefined props)\n    let new_process_instance = _objectSpread({}, new ProcessInstance(), {}, process_template);\n\n    for (let activ in new_process_instance.activities) {\n      new_process_instance.activities[activ] = _objectSpread({}, new ActivityInstance(), {}, new_process_instance.activities[activ]);\n    }\n\n    new_process_instance.user_name = user_name;\n    new_process_instance.start_date = new Date();\n    new_process_instance.activeStep = 0;\n    store.put(new_process_instance, [new_process_instance.title, new_process_instance.user_name]);\n  });\n}\nexport async function get_process_templates() {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(DB_OBJ_STORES.process_templates, store => {\n      let request = store.getAll();\n\n      request.onsuccess = function () {\n        resolve(request.result);\n      };\n    });\n  });\n}\nexport async function get_process_instance(title, user_name) {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n      let request = store.get(IDBKeyRange.only([title, user_name]));\n\n      request.onsuccess = function () {\n        resolve(request.result);\n      };\n    });\n  });\n}\nexport async function get_activity_templates() {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(DB_OBJ_STORES.activity_templates, store => {\n      let request = store.getAll();\n\n      request.onsuccess = function () {\n        resolve(request.result);\n      };\n    });\n  });\n}\nexport async function process_instance_update_step(process, step) {\n  connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n    if (process.user_name !== undefined) {\n      process.activeStep = step;\n      let key = [process.title, process.user_name];\n      store.put(process, key);\n    } else {\n      console.error(\"user_name was undefined\");\n    }\n  });\n}\nexport async function process_instance_update_activity_state(process, activity, new_state) {\n  connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n    if (process.user_name !== undefined) {\n      let activityIndex = process.activities.indexOf(activity);\n\n      if (activityIndex >= 0) {\n        process.activities[activityIndex].state = new_state;\n        let key = [process.title, process.user_name];\n        store.put(process, key);\n      }\n    } else {\n      console.error(\"user_name was undefined\");\n    }\n  });\n}\nexport async function process_instance_reset_date(process) {\n  connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n    if (process.user_name !== undefined) {\n      process.done_date = undefined;\n\n      for (let activity of process.activities) {\n        activity.end_date = undefined;\n      }\n\n      let key = [process.title, process.user_name];\n      store.put(process, key);\n    } else {\n      console.error(\"user_name was undefined\");\n    }\n  });\n}\nexport async function get_process_instances() {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n      let request = store.getAll();\n\n      request.onsuccess = function () {\n        resolve(request.result);\n      };\n    });\n  });\n}","map":{"version":3,"sources":["/Users/elgstrom/Desktop/Netgain/netgain-1/src/backend/ts/database.ts"],"names":["ProcessInstance","ActivityInstance","DB_NAME","DB_VERSION","DB_OBJ_STORES","init_database","indexedDB","window","open","onupgradeneeded","db","result","store","objectStoreNames","contains","createObjectStore","autoIncrement","connect_2_object_store","obj_s_name","callback","onsuccess","tx","transaction","objectStore","save_process_template","p","process_templates","put","title","does_process_exist","process_title","Promise","resolve","reject","request","get","delete_process_template","delete","save_activity_template","a","activity_templates","does_activity_exist","activity_title","delete_activity_template","delete_process_instance","process_instances","Array","user_name","create_process_instance","process_template","new_process_instance","activ","activities","start_date","Date","activeStep","get_process_templates","getAll","get_process_instance","IDBKeyRange","only","get_activity_templates","process_instance_update_step","process","step","undefined","key","console","error","process_instance_update_activity_state","activity","new_state","activityIndex","indexOf","state","process_instance_reset_date","done_date","end_date","get_process_instances"],"mappings":"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","sourcesContent":["import {\n  Process,\n  ProcessInstance,\n  Activity,\n  ActivityInstance\n} from \"./common_define\";\nconst DB_NAME = \"test_db\";\nconst DB_VERSION = 2;\nexport enum DB_OBJ_STORES {\n  process_instances = \"process_instances\",\n  process_templates = \"process_templates\",\n  activity_templates = \"activity_templates\"\n}\n\nexport function init_database() {\n  let indexedDB = window.indexedDB;\n  let open = indexedDB.open(DB_NAME, DB_VERSION);\n\n  open.onupgradeneeded = function() {\n    let db = open.result;\n    for (let store in DB_OBJ_STORES) {\n      if (!db.objectStoreNames.contains(store)) {\n        db.createObjectStore(store, { autoIncrement: true });\n      }\n    }\n  };\n}\n\nfunction connect_2_object_store(obj_s_name: DB_OBJ_STORES, callback: Function) {\n  let indexedDB = window.indexedDB;\n  let open = indexedDB.open(DB_NAME, DB_VERSION);\n\n  open.onupgradeneeded = function() {\n    init_database();\n  };\n\n  open.onsuccess = function() {\n    let db = open.result;\n    if (!db.objectStoreNames.contains(obj_s_name)) {\n      db.createObjectStore(obj_s_name);\n    }\n    let tx = db.transaction(obj_s_name, \"readwrite\");\n    let store = tx.objectStore(obj_s_name);\n\n    callback(store);\n  };\n}\n\nexport function save_process_template(p: Process) {\n  connect_2_object_store(\n    DB_OBJ_STORES.process_templates,\n    (store: IDBObjectStore) => {\n      store.put(p, p.title);\n    }\n  );\n}\n\nexport async function does_process_exist(\n  process_title: string\n): Promise<Boolean> {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(\n      DB_OBJ_STORES.process_templates,\n      (store: IDBObjectStore) => {\n        let request = store.get(process_title);\n        request.onsuccess = function() {\n          if (request.result) {\n            resolve(true);\n          } else {\n            resolve(false);\n          }\n        };\n      }\n    );\n  });\n}\n\nexport function delete_process_template(p: Process) {\n  connect_2_object_store(\n    DB_OBJ_STORES.process_templates,\n    (store: IDBObjectStore) => {\n      store.delete(p.title);\n    }\n  );\n}\n\nexport function save_activity_template(a: Activity) {\n  connect_2_object_store(\n    DB_OBJ_STORES.activity_templates,\n    (store: IDBObjectStore) => {\n      store.put(a, a.title);\n    }\n  );\n}\n\nexport async function does_activity_exist(\n  activity_title: string\n): Promise<Boolean> {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(\n      DB_OBJ_STORES.activity_templates,\n      (store: IDBObjectStore) => {\n        let request = store.get(activity_title);\n        request.onsuccess = function() {\n          if (request.result) {\n            resolve(true);\n          } else {\n            resolve(false);\n          }\n        };\n      }\n    );\n  });\n}\n\nexport function delete_activity_template(a: Activity) {\n  connect_2_object_store(\n    DB_OBJ_STORES.activity_templates,\n    (store: IDBObjectStore) => {\n      store.delete(a.title);\n    }\n  );\n}\n\nexport function delete_process_instance(p: ProcessInstance) {\n  connect_2_object_store(\n    DB_OBJ_STORES.process_instances,\n    (store: IDBObjectStore) => {\n      store.delete(new Array<any>(p.title, p.user_name));\n    }\n  );\n}\n\nexport function create_process_instance(\n  process_template: Process,\n  user_name: string\n) {\n  connect_2_object_store(\n    DB_OBJ_STORES.process_instances,\n    (store: IDBObjectStore) => {\n      //TODO is there a better way of doing this? than using as (can cause problems with undefined props)\n      let new_process_instance = {\n        ...new ProcessInstance(),\n        ...process_template\n      };\n      for (let activ in new_process_instance.activities) {\n        new_process_instance.activities[activ] = {\n          ...new ActivityInstance(),\n          ...new_process_instance.activities[activ]\n        };\n      }\n      new_process_instance.user_name = user_name;\n      new_process_instance.start_date = new Date();\n      new_process_instance.activeStep = 0;\n      store.put(new_process_instance, [\n        new_process_instance.title,\n        new_process_instance.user_name\n      ]);\n    }\n  );\n}\n\nexport async function get_process_templates(): Promise<Array<Process>> {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(\n      DB_OBJ_STORES.process_templates,\n      (store: IDBObjectStore) => {\n        let request = store.getAll();\n        request.onsuccess = function() {\n          resolve(request.result);\n        };\n      }\n    );\n  });\n}\n\nexport async function get_process_instance(\n  title: string,\n  user_name: string\n): Promise<ProcessInstance> {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(\n      DB_OBJ_STORES.process_instances,\n      (store: IDBObjectStore) => {\n        let request = store.get(IDBKeyRange.only([title, user_name]));\n        request.onsuccess = function() {\n          resolve(request.result);\n        };\n      }\n    );\n  });\n}\n\nexport async function get_activity_templates(): Promise<Array<Activity>> {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(\n      DB_OBJ_STORES.activity_templates,\n      (store: IDBObjectStore) => {\n        let request = store.getAll();\n        request.onsuccess = function() {\n          resolve(request.result);\n        };\n      }\n    );\n  });\n}\n\nexport async function process_instance_update_step(\n  process: ProcessInstance,\n  step: number\n) {\n  connect_2_object_store(\n    DB_OBJ_STORES.process_instances,\n    (store: IDBObjectStore) => {\n      if (process.user_name !== undefined) {\n        process.activeStep = step;\n        let key = [process.title, process.user_name];\n        store.put(process, key);\n      } else {\n        console.error(\"user_name was undefined\");\n      }\n    }\n  );\n}\n\nexport async function process_instance_update_activity_state(\n  process: ProcessInstance,\n  activity: ActivityInstance,\n  new_state: number\n) {\n  connect_2_object_store(\n    DB_OBJ_STORES.process_instances,\n    (store: IDBObjectStore) => {\n      if (process.user_name !== undefined) {\n        let activityIndex = process.activities.indexOf(activity);\n        if (activityIndex >= 0) {\n          process.activities[activityIndex].state = new_state;\n          let key = [process.title, process.user_name];\n          store.put(process, key);\n        }\n      } else {\n        console.error(\"user_name was undefined\");\n      }\n    }\n  );\n}\n\nexport async function process_instance_reset_date(\n  process: ProcessInstance\n) {\n  connect_2_object_store(\n    DB_OBJ_STORES.process_instances,\n    (store: IDBObjectStore) => {\n      if (process.user_name !== undefined) {\n        process.done_date = undefined;\n        for (let activity of process.activities) {\n          activity.end_date = undefined;\n        }\n        let key = [process.title, process.user_name];\n        store.put(process, key);\n      } else {\n        console.error(\"user_name was undefined\");\n      }\n    }\n  );\n}\n\nexport async function get_process_instances(): Promise<Array<ProcessInstance>> {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(\n      DB_OBJ_STORES.process_instances,\n      (store: IDBObjectStore) => {\n        let request = store.getAll();\n        request.onsuccess = function() {\n          resolve(request.result);\n        };\n      }\n    );\n  });\n}\n"]},"metadata":{},"sourceType":"module"}