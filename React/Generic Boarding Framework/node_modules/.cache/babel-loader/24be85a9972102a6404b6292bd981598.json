{"ast":null,"code":"const DB_NAME = \"test_db\";\nexport let DB_OBJ_STORES;\n\n(function (DB_OBJ_STORES) {\n  DB_OBJ_STORES[\"process_instances\"] = \"process_instances\";\n  DB_OBJ_STORES[\"process_templates\"] = \"process_templates\";\n})(DB_OBJ_STORES || (DB_OBJ_STORES = {}));\n\nexport function init_database() {\n  let indexedDB = window.indexedDB;\n  let open = indexedDB.open(DB_NAME, 2);\n\n  open.onupgradeneeded = function () {\n    let db = open.result;\n\n    for (let store in DB_OBJ_STORES) {\n      if (!db.objectStoreNames.contains(store)) {\n        db.createObjectStore(store, {\n          autoIncrement: true\n        });\n      }\n    }\n  };\n}\n\nfunction connect_2_object_store(obj_s_name, callback) {\n  let indexedDB = window.indexedDB;\n  let open = indexedDB.open(DB_NAME, 2);\n\n  open.onupgradeneeded = function () {\n    init_database();\n  };\n\n  open.onsuccess = function () {\n    let db = open.result;\n\n    if (!db.objectStoreNames.contains(obj_s_name)) {\n      db.createObjectStore(obj_s_name);\n    }\n\n    let tx = db.transaction(obj_s_name, 'readwrite');\n    let store = tx.objectStore(obj_s_name);\n    callback(store);\n  };\n}\n\nexport function save_process_template(p) {\n  connect_2_object_store(DB_OBJ_STORES.process_templates, store => {\n    store.put(p, p.title);\n  });\n}\nexport function delete_process_template(p) {\n  connect_2_object_store(DB_OBJ_STORES.process_templates, store => {\n    store.delete(p.title);\n  });\n}\nexport function delete_process_instance(p) {\n  connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n    store.delete(new Array(p.title, p.user_name));\n  });\n}\nexport function create_process_instance(process_template, user_name) {\n  connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n    //TODO is there a better way of doing this? than using as (can cause problems with undefined props)\n    let new_process_instance = process_template;\n    new_process_instance.activities = new_process_instance.activities;\n    new_process_instance.user_name = user_name;\n    new_process_instance.start_date = new Date();\n    new_process_instance.step = 0;\n    store.put(new_process_instance, [new_process_instance.title, new_process_instance.user_name]);\n  });\n}\nexport async function get_process_templates() {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(DB_OBJ_STORES.process_templates, store => {\n      let request = store.getAll();\n\n      request.onsuccess = function () {\n        resolve(request.result);\n      };\n    });\n  });\n}\nexport async function get_process_instance(title, user_name) {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n      let request = store.get(IDBKeyRange.only([title, user_name]));\n\n      request.onsuccess = function () {\n        resolve(request.result);\n      };\n    });\n  });\n}\nexport async function process_instance_update_step(process, step) {\n  connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n    if (process.user_name !== undefined) {\n      process.step = step;\n      let key = [process.title, process.user_name];\n      store.put(process, key);\n    } else {\n      console.error(\"user_name was undefined\");\n    }\n  });\n}\nexport async function get_process_instances() {\n  return new Promise((resolve, reject) => {\n    connect_2_object_store(DB_OBJ_STORES.process_instances, store => {\n      let request = store.getAll();\n\n      request.onsuccess = function () {\n        resolve(request.result);\n      };\n    });\n  });\n}","map":{"version":3,"sources":["/Users/elgstrom/Desktop/Netgain/netgain-1/src/backend/ts/database.ts"],"names":["DB_NAME","DB_OBJ_STORES","init_database","indexedDB","window","open","onupgradeneeded","db","result","store","objectStoreNames","contains","createObjectStore","autoIncrement","connect_2_object_store","obj_s_name","callback","onsuccess","tx","transaction","objectStore","save_process_template","p","process_templates","put","title","delete_process_template","delete","delete_process_instance","process_instances","Array","user_name","create_process_instance","process_template","new_process_instance","activities","start_date","Date","step","get_process_templates","Promise","resolve","reject","request","getAll","get_process_instance","get","IDBKeyRange","only","process_instance_update_step","process","undefined","key","console","error","get_process_instances"],"mappings":"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","sourcesContent":["import { Process, ProcessInstance, Activity, ActivityInstance } from './common_define'\nconst DB_NAME = \"test_db\"\nexport enum DB_OBJ_STORES {\n    process_instances = \"process_instances\",\n    process_templates = \"process_templates\",\n}\n\nexport function init_database() {\n    let indexedDB = window.indexedDB;\n    let open = indexedDB.open(DB_NAME, 2);\n\n    open.onupgradeneeded = function () {\n        let db = open.result;\n        for (let store in DB_OBJ_STORES) {\n            if (!db.objectStoreNames.contains(store)) {\n                db.createObjectStore(store, { autoIncrement: true });\n            }\n        }\n    }\n}\n\nfunction connect_2_object_store(obj_s_name: DB_OBJ_STORES, callback: Function) {\n    let indexedDB = window.indexedDB;\n    let open = indexedDB.open(DB_NAME, 2);\n\n    open.onupgradeneeded = function () {\n        init_database();\n    }\n\n    open.onsuccess = function () {\n        let db = open.result;\n        if (!db.objectStoreNames.contains(obj_s_name)) {\n            db.createObjectStore(obj_s_name);\n        }\n        let tx = db.transaction(obj_s_name, 'readwrite');\n        let store = tx.objectStore(obj_s_name);\n\n        callback(store);\n    }\n}\n\nexport function save_process_template(p: Process) {\n    connect_2_object_store(DB_OBJ_STORES.process_templates, (store: IDBObjectStore) => {\n        store.put(p, p.title);\n    });\n}\n\nexport function delete_process_template(p: Process) {\n    connect_2_object_store(DB_OBJ_STORES.process_templates, (store: IDBObjectStore) => {\n        store.delete(p.title);\n    });\n}\n\nexport function delete_process_instance(p: ProcessInstance) {\n    connect_2_object_store(DB_OBJ_STORES.process_instances, (store: IDBObjectStore) => {\n        store.delete(new Array<any>(p.title, p.user_name));\n    });\n}\n\nexport function create_process_instance(process_template: Process, user_name: string) {\n    connect_2_object_store(DB_OBJ_STORES.process_instances, (store: IDBObjectStore) => {\n        //TODO is there a better way of doing this? than using as (can cause problems with undefined props)\n        let new_process_instance = process_template as ProcessInstance;\n        new_process_instance.activities = new_process_instance.activities as Array<ActivityInstance>;\n        new_process_instance.user_name = user_name;\n        new_process_instance.start_date = new Date();\n        new_process_instance.step = 0;\n        store.put(new_process_instance, [new_process_instance.title, new_process_instance.user_name]);\n    });\n}\n\nexport async function get_process_templates(): Promise<Array<Process>> {\n    return new Promise((resolve, reject) => {\n        connect_2_object_store(DB_OBJ_STORES.process_templates, (store: IDBObjectStore) => {\n            let request = store.getAll();\n            request.onsuccess = function () {\n                resolve(request.result);\n            }\n        });\n    });\n}\n\nexport async function get_process_instance(title: string, user_name: string): Promise<ProcessInstance> {\n    return new Promise((resolve, reject) => {\n        connect_2_object_store(DB_OBJ_STORES.process_instances, (store: IDBObjectStore) => {\n            let request = store.get(IDBKeyRange.only([title, user_name]));\n            request.onsuccess = function () {\n                resolve(request.result);\n            }\n        });\n    });\n}\n\nexport async function process_instance_update_step(process: ProcessInstance, step: number) {\n    connect_2_object_store(DB_OBJ_STORES.process_instances, (store: IDBObjectStore) => {\n        if (process.user_name !== undefined){\n            process.step = step;\n            let key = [process.title, process.user_name];\n            store.put(process, key);\n        }else{\n            console.error(\"user_name was undefined\");\n        }\n    });\n\n}\n\nexport async function get_process_instances(): Promise<Array<ProcessInstance>> {\n    return new Promise((resolve, reject) => {\n        connect_2_object_store(DB_OBJ_STORES.process_instances, (store: IDBObjectStore) => {\n            let request = store.getAll();\n            request.onsuccess = function () {\n                resolve(request.result);\n            }\n        })\n    })\n}"]},"metadata":{},"sourceType":"module"}